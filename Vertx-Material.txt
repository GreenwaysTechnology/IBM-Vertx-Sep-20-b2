Vert.x:
.......

What is Vertx?

Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.

Vertx is functional,event driven,object oriented,reactive,non blocking io and async tookit for building "distributed application - Micro service" on java virtual machine.

Vert.x is Polyglot tool kit for building micro services application.

Verx allows different programming languages can talk each other.


Polyglot means multi technology /language.

 Vertx supports Polyglot on jvm.

Does JVM support multi language(Polyglot)?

   Yes!.

2002,JCP published  specfication called "multi language" on jvm.
 
Groovy, was the first reference implementation of that spec 
Kotlin
Jython - python + java

Vetx PolyGlot

You can use Vert.x with multiple languages including Java, Kotlin, JavaScript, Groovy, Ruby and Scala.

Vert.x doesn't preach about what language is best — you choose the languages you want based on the task at hand and the skill-set of your team.

We provide idiomatic APIs for every language that Vert.x supports.


 How these languages works on jvm/
   jvm contract is only "byte code"

             groovy,kotlin,javascript,scala,ruby.......
	                |
                    compilers
                        |
                      .class
                        |
                       jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

non blocking io and async :
...........................

IO:

Hardware devices typically provide the ability to input data into the computer or output data from the computer.

To simplify the ability to support a variety of hardware devices, standardized application programming interfaces (API) are used.

Application programs use the "System Call API" to request one of a finite set of preset I/O requests from the Operating System.

The Operating System uses algorithms for processing the request that are device independent.


The Operating System uses another API to request data from the device driver.

The device driver is third party software that knows how to interact with the specific device to perform the I/O.

Sometimes we have a layering of device drivers where one device driver will call on another device driver to facilitate the I/O.

 An example of this is when devices are connected to a USB port. The driver for the device will make use of the USB device driver to facilitate passing data to and from the device.


IO SYSTEM CALL Api:

Java - io api
 |
jvm
jni -  io api - java native interface api , which low level api to os
|
os
|
system calls - os io api
|
device driver - io api
|
----------device


READ-----------------|windows---read


Socket :

 It is entry and exit point of device io world.
Socket isloates  kernal space and device drivers


Blocking code in java:
.....................

blocking network socket app.

package com.ibm.blocking;


import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class BlockingEco {
    public static void main(String[] args) throws Throwable {
        //this api interally communicates network interface card
        ServerSocket server = new ServerSocket();
        server.bind(new InetSocketAddress(3000));
        System.out.println("Blocking Socket : listening for new Request");
        while (true) {   // <1>
            Socket socket = server.accept();
            //each incomming request(socket request) allocate in a separate thread
            new Thread(clientHandler(socket)).start();
        }
    }

    private static Runnable clientHandler(Socket socket) {
        return () -> {

            try (
                    BufferedReader reader = new BufferedReader(
                            new InputStreamReader(socket.getInputStream()));
                    PrintWriter writer = new PrintWriter(
                            new OutputStreamWriter(socket.getOutputStream()))) {
                String line = "";
                while (!"/quit".equals(line)) {
                    line = reader.readLine();      // <2>
                    System.out.println("~ " + line);
                    writer.write(line + "\n");  // <3>
                    writer.flush();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
    }

}


Why not blocking?

Blocking APIs waste resources, increase costs


The main problem with the code above ,is that it allocates a new thread for each incoming connection
and threads are anything but cheap resources. 

A thread needs memory, and the more threads you have, the more you put pressure on the operating system kernel scheduler, as it needs to give CPU time to the thread

 Input/output operations such as readLine and write may block the thread, meaning that it is being parked by the operating system. This happens for two reasons:

A read operation may be waiting for data to arrive from the network.
A write operation may have to wait for buffers to be drained if they are full from a previous write operation

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Asynchronous programming with non-blocking I/O:

Instead of waiting for I/O operations to complete, we can shift to non-blocking I/O.

You may have already sampled this with the select function in C.


The idea behind non-blocking I/O is to request a (blocking) operation, and move on to doing other tasks until the operation is ready.

For example a non-blocking read may ask for up to 256 bytes over a network socket, and the execution thread does other things (like dealing with another connection) until data has been put into the buffers, ready for consumption in memory.

In this model, many concurrent connections can be multiplexed on a single thread, as network latency typically exceeds the CPU time it takes to read incoming bytes.


Low Level System calls for non blocking:

I/O multiplexing
I/O multiplexing is the the ability to perform I/O operations on multiple file descriptors. Input operations like read, accept and calls for receiving messages block when there is no incoming data. So, if an input call is made and it blocks, we may miss data from other file descriptors. To circumvent this, I/O multiplexing calls, viz., select, poll, and the epoll API calls, are provided. A process blocks on an I/O multiplexing call. When this call returns, the process is provided a set of file descriptors which are ready for I/O. And, the process can do I/O on these file descriptors before it goes for the next iteration of the I/O multiplexing call

1.select
2.poll
3.  aio_read - asynchronous read

1.select:
select is a system call and application programming interface (API) in Unix-like and POSIX-compliant operating systems for examining the status of file descriptors of open input/output channels.

select() allows a program to monitor multiple file descriptors,
       waiting until one or more of the file descriptors become "ready" for
       some class of I/O operation (e.g., input possible).  A file
       descriptor is considered ready if it is possible to perform a
       corresponding I/O operation (e.g., read(2), or a sufficiently small
       write(2)) without blocking.


       select() can monitor only file descriptors numbers that are less than
       FD_SETSIZE; poll and epoll  do not have this limitation. 

2.poll:
poll is a POSIX system call to wait for one or more file descriptors to become ready for use
poll, ppoll - wait for some event on a file descriptor.

Select has lot of drawbacks.

Poll is fundamentally is event driven.
Poll listens for file descriptor events.


https://man7.org/linux/man-pages/man2/poll.2.html

Other advanced implementations:

1.kqueue, 
2.epoll, 
3./dev/poll
4.I/O completion ports



epoll - I/O event notification facility

-event poll api
-monitors multiple file descriptors
-specific to linux

Kernel queue (kqueue)
If you are programming with asynchronous (non-blocking) frameworks, then most likely this framework is using kernel polling APIs under the hood. Using an infinite loop, kernel polling APIs check for events and notify the caller when an event has occurred. 
 For example when an HTTP request is fired, in each iteration of the loop a check is done to see if data already has returned from the server. 

Linux uses epoll
BSD and OSX use kqueue
Windows uses IOCP
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Event Loop:
..........
events are picked up solely from epoll and ‘dispatched’ on the same thread within each loop iteration to our request handler ‘app’.

java and non blocking:
......................

Does java support non blocking apis?

No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"-NONBlocking IO.


NIO version: non blocking version

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Pattern;

public class AsynchronousEcho {

  public static void main(String[] args) throws IOException {
    Selector selector = Selector.open();

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(3000));
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
      selector.select();
      Iterator<SelectionKey> it = selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key = it.next();
        if (key.isAcceptable()) {
          newConnection(selector, key);
        } else if (key.isReadable()) {
          echo(key);
        } else if (key.isWritable()) {
          continueEcho(selector, key);
        }
        it.remove();
      }
    }
  }

  private static class Context {
    private final ByteBuffer nioBuffer = ByteBuffer.allocate(512);
    private String currentLine = "";
    private boolean terminating = false;
  }

  private static final HashMap<SocketChannel, Context> contexts = new HashMap<>();

  private static void newConnection(Selector selector, SelectionKey key) throws IOException {
    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
    SocketChannel socketChannel = serverSocketChannel.accept();
    socketChannel
      .configureBlocking(false)
      .register(selector, SelectionKey.OP_READ);
    contexts.put(socketChannel, new Context());
  }

  private static final Pattern QUIT = Pattern.compile("(\\r)?(\\n)?/quit$");

  private static void echo(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      socketChannel.read(context.nioBuffer);
      context.nioBuffer.flip();
      context.currentLine = context.currentLine + Charset.defaultCharset().decode(context.nioBuffer);
      if (QUIT.matcher(context.currentLine).find()) {
        context.terminating = true;
      } else if (context.currentLine.length() > 16) {
        context.currentLine = context.currentLine.substring(8);
      }
      context.nioBuffer.flip();
      int count = socketChannel.write(context.nioBuffer);
      if (count < context.nioBuffer.limit()) {
        key.cancel();
        socketChannel.register(key.selector(), SelectionKey.OP_WRITE);
      } else {
        context.nioBuffer.clear();
        if (context.terminating) {
          cleanup(socketChannel);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }

  private static void cleanup(SocketChannel socketChannel) throws IOException {
    socketChannel.close();
    contexts.remove(socketChannel);
  }

  private static void continueEcho(Selector selector, SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      int remainingBytes = context.nioBuffer.limit() - context.nioBuffer.position();
      int count = socketChannel.write(context.nioBuffer);
      if (count == remainingBytes) {
        context.nioBuffer.clear();
        key.cancel();
        if (context.terminating) {
          cleanup(socketChannel);
        } else {
          socketChannel.register(selector, SelectionKey.OP_READ);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }
}

Problmes with NIO :

It is also important to note that like most JDK APIs, java.nio focuses solely on what it does (here, I/O APIs).
 
->It does not provide higher-level protocol-specific helpers, like for writing HTTP clients and servers.
 
->Also, java.nio does not prescribe a threading model, which is still important to properly utilize CPU 
cores, handle asynchronous I/O events, and articulate the application processing logic.

->This is why, in practice, developers rarely deal with Java NIO. 
.......................................................................................................

Networking libraries like Netty and Apache Mina solve the shortcomings of Java NIO


NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns- The first Reactor Model on jvm.

        	     Netty Application
		             |
          	         nettycore
			     |
			    nio
			     |
		            jvm

Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library

		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Vertx:

Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM.
 initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

			
			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


Objective of VertX:
   
    100% non blocking applications on jvm.


NonBlocking IO Apis


                     NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
	            	|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				                         |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


///////////////////////////////////////////////////////////////////////////////////////////////////////

Vertx Runtime:

Vertx run time is powered by non blocking io arch

Vertx uses event loops
 -event loops are used to process events which are dispatched by kernal.

Event :

  collection of event and data
  How to read data?
    you need handler- callback functions


Vertx uses multi core event loop threads where as node js has only one event loop thread.

Vertx uses per cpu core - 2 event loop, lets say i have 12 cores - 12 *2 =24 event loops.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Simple Vertx Event loop simulation:
package com.ibm.eventloop;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.function.Consumer;

public final class EventLoop {

    //event queue
    private final ConcurrentLinkedDeque<Event> events = new ConcurrentLinkedDeque<>();
    //handler ; key-value binding
    private final ConcurrentHashMap<String, Consumer<Object>> handlers = new ConcurrentHashMap<>();

    public static void main(String[] args) {
        EventLoop eventLoop = new EventLoop();

        new Thread(() -> {
            for (int n = 0; n < 6; n++) {
                delay(1000);
                //event dispatch
                eventLoop.dispatch(new EventLoop.Event("tick", n));
            }
            eventLoop.dispatch(new EventLoop.Event("stop", null));
        }).start();

        new Thread(() -> {
            delay(2500);
            eventLoop.dispatch(new EventLoop.Event("hello", "beautiful world" + Thread.currentThread().getName()));
            delay(800);
            eventLoop.dispatch(new EventLoop.Event("hello", "beautiful universe"));
        }).start();

        eventLoop.dispatch(new EventLoop.Event("hello", "world!"));
        eventLoop.dispatch(new EventLoop.Event("foo", "bar"));

        //event registration with callbacks ; queue binding
        eventLoop
                .on("hello", s -> System.out.println("hello " + s))
                .on("tick", n -> System.out.println("tick #" + n))
                .on("stop", v -> eventLoop.stop())
                .run();

        System.out.println("Bye!");
    }

    private static void delay(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    public EventLoop on(String key, Consumer<Object> handler) {
        handlers.put(key, handler);
        return this;
    }

    public void dispatch(Event event) {
        events.add(event);
    }

    public void run() {
        while (!(events.isEmpty() && Thread.interrupted())) {
            if (!events.isEmpty()) {
                Event event = events.pop();
                if (handlers.containsKey(event.key)) {
                    handlers.get(event.key).accept(event.data);
                } else {
                    System.err.println("No handler for key " + event.key);
                }
            }
        }
    }

    public void stop() {
        Thread.currentThread().interrupt();
    }

    public static final class Event {
        private final String key;
        private final Object data;

        public Event(String key, Object data) {
            this.key = key;
            this.data = data;
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////

Lets enter into vertx app; how to build non blocking and async apps:
....................................................................

Lets code:

-Vertx Project setup

-Maven Project
-Gradle Project

1.plain maven project, add vertx depedencies,You can use template entry method provided by vertx .

2.Vertx Starter project

3.Vertx maven cli project

Vetx Distribution:

-maven
-zip

download zip and extract and set path 
C:\softwares\vert.x-3.9.2-full\vertx\bin



&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
How to run vertx application?

We have many ways:

1.via maven.

running:
./mvnw clean compile exec:java
or
mvn clean compile exec:java

2.fat jar running:

you can pack vertx application into fat jar and you can


1.Create fat jar

mvnw clean package

2. Running

java -jar target/vertx-apps-1.0.0-SNAPSHOT-fat.jar


3.via vertx command line.


vertx run ProgrammName.java

C:\session\ibm\Sep\vertx-apps\src\main\java\com\ibm\vertx>vertx run MainVerticle.java



3.via vertx command line.


vertx run ProgrammName.java

C:\session\ibm\Sep\vertx-apps\src\main\java\com\ibm\vertx>vertx run MainVerticle.java
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
HTTP server started on port 8888
Succeeded in deploying verticle


4.via coding - to be discussed later

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Vertx apps:

vertx application can be small to big enterprise microservice application.

Like spring , starts with spring-core , after that ,spring-mvc,spring-data....(modules

Vertx also begins modules

vertx-core ,vertx-web,vertx-data..............

vertx-core:
..........

Core Vertx Concepts:
....................

1.Vertx Instance , so Called "Vertx Engine". === Spring Container
2.Verticles ; so called an Object through which you can create apps.

io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.

To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler).

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles



How to create vertx instance?
package com.ibm.vertx.core;

import io.vertx.core.Vertx;

public class VertxInstanceCreation {
  public static void main(String[] args) {
    //create vertx instance
    Vertx vertxInstance = Vertx.vertx();
    System.out.println(vertxInstance.getClass().getName());

  }
}

Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance.
  -It is based on design pattern called "Actor-like Model"
  -Verticles are bound to "Event loop" , are processed by event loop threads.

Verticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment

How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.


eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}


package com.ibm.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Vertx;

public class HelloWorldVerticle extends AbstractVerticle {

  //life cycle methods
  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("init");
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("start");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("stop");
  }
}

How to deploy(run) the above code?

if you want to run any code, you need entry point-main method.

vertx provides entry method-main method called "Launcher"

Launcher is a program, which has built in main method.

In general , lanucher is "vertx" runtime command only


in pom.xml we have lanucher configuration.

  <properties>
    <main.verticle>com.ibm.vertx.core.HelloWorldVerticle</main.verticle>
  </properties>


   <manifestEntries>
           <Main-Class>io.vertx.core.Launcher</Main-Class>
           <Main-Verticle>${main.verticle}</Main-Verticle>
    </manifestEntries>

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

In vertx , verticle deployment itself is async, which is non blocking.

package com.ibm.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;

public class GreeterVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    //Get Vertx(container)
    Vertx vertxIns = Vertx.vertx();
    //you have method called deploy
    //way -1 - create verticle object new
    vertxIns.deployVerticle(new GreeterVerticle());
    //way -2 : passing class name
    vertxIns.deployVerticle(GreeterVerticle.class.getName());
    //way 3; string class name
    vertxIns.deployVerticle("com.ibm.vertx.core.GreeterVerticle");
    
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Greeter start");
  }
}

Vertx team has provided a utility class for verticle deployment?
   Vertx vertxIns = Vertx.vertx(); - syntax not necessary.


******************************************************************************************

package com.ibm.vertx.core.verticles;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;


public class MainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(MainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Main Verticle");
    vertx.deployVerticle(UserVerticle.class.getName());
  }
}
	
package com.ibm.vertx.core.verticles;

import io.vertx.core.AbstractVerticle;

public class UserVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("User Verticle");
  }
}

Vert x and Event loop:

Vertx process events comming from kernal space , via event loop, still it is while loop but that loop bound to a thread , that thread is called event loop thread.

Every verticle by default is bound to a thread Event loop thread.

Verticle can handle events and process them.

How many event loops are there in vertx?

In node js , only one event loop.

In vertx per cpu core 2 event loops.

eg , if i have 12 cores - 24 event loop.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

How to process events 

-Verticle
-Event loop Thread

-Event handlers



Event Handlers:
...............

Vertx Event Handlers can be in written in two ways

1.Future && Promise Pattern : Functional style
2.Reactive Pattern - RxJava2


if you come from java script && node.js background,you know the concept called "Callback function" - callback function is other wise called as "listener function" or "handler function".



1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop starts processing.

What is handler function/callback function/listener function for?
To handle async success /failure result.
   The result of async opertion could be either success or failure


io.vertx.Future:

-it is interface used to handle async success/failure results.

io.vertx.core

Future Interface 
				AsyncResult       Handler
				-------------------------
					   |
				         Future



Future interface is used to handle the result of async operation.


Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation

 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate  inside this api.


Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure

AsyncResult interface apis

 -result() - get the success result sent by Future
 -cause()   -get the failure result sent by Future
 -succeed() -test whether it was success or failure
 -failed()  -test whether it was failure or success


Future Object creation and encaspulating data

1.Future future = Future.future()
 future.complete(T value)
 future.fail(T value)

2.static factory api
Future.succeedFuture(T value)
  Future.FailedFuture(T value)

3.function as parameter pattern ; callback pattern


package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.example.util.Runner;

class FutureVerticle extends AbstractVerticle {

  //create empty future; no response return
  public Future<Void> getEmptyFuture() {
    //create Future object
    Future<Void> future = Future.future();
    //empty response injection
    future.complete();
    return future;
  }

  //how to send success results : can be any type
  public Future<String> getSuccessFuture() {
    //create Future object
    Future<String> future = Future.future();
    //empty response injection
    future.complete("Hello I am fututure result!!");
    return future;
  }

  //how to send failure reponse;
  public Future<String> getFailedFuture() {
    //create Future object
    Future<String> future = Future.future();
    //empty response injection
    future.fail("Some thing went wrong");
    return future;
  }

  //how to send success or failure based on biz logic
  public Future<String> validate(String userName, String password) {
    //create Future object
    Future<String> future = Future.future();

    //biz logic
    if (userName.equals("admin") && password.equals("admin")) {
      future.complete("Login Success");
    } else {
      future.fail("Login Failed");
    }

    return future;
  }

  //facotry api
  public Future<String> validateUsingFactory(String userName, String password) {
    //biz logic
    if (userName.equals("admin") && password.equals("admin")) {
      return Future.succeededFuture("Login success");
    } else {
      return Future.failedFuture("Login Failed");
    }
  }

  //function as parameter pattern
  public void validateWithFunction(Handler<AsyncResult<String>> aHandler) {
    //biz logic
    String userName = "admin";
    String password = "admin";
    if (userName.equals("admin") && password.equals("admin")) {
      aHandler.handle(Future.succeededFuture("login success"));
    } else {
      aHandler.handle(Future.failedFuture("Login Failed"));
    }

  }


  @Override
  public void start() throws Exception {
    super.start();
    //handle empty the response
    if (getEmptyFuture().succeeded()) {
      System.out.println("got empty response");
    }
    //set handler; using anonmous inner class
    getSuccessFuture().setHandler(new Handler<AsyncResult<String>>() {
      @Override
      public void handle(AsyncResult<String> asyncResult) {
        //value access
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result());
        } else {
          System.out.println(asyncResult.cause());
        }
      }
    });
    //set handler; using lambda expression
    getSuccessFuture().setHandler(asyncResult -> {
      //value access
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    //onComplete handler
    getSuccessFuture().onComplete(asyncResult -> {
      //value access
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    //onSuccess will give direct result
    getSuccessFuture().onSuccess(response -> {
      System.out.println(response);
    });
    getSuccessFuture().onSuccess(System.out::println);

    //handle failures
    getFailedFuture().onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      }
    });
    getFailedFuture().onFailure(System.out::println);

    //login
    validate("admin", "admin").onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    validate("foo", "foo")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

    validateUsingFactory("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

    //funciton as parameter ; handler as a parameter
    validateWithFunction(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });

  }
}


public class FutureMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FutureMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new FutureVerticle());
  }
}


Async Wrapper Object : Promise:
...............................

Promise is async abstraction largly promoted by javascript community.

Dont Compare  javascript Promises with Vertx Promises , because both are different.

Promise is "semantically meaningfull abstraction" for handling asyn results.

Many times developers confuse with java Future and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis.

Promises must be converted into Future before processing.


package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class PromiseVerticle extends AbstractVerticle {

  //how to send success results : can be any type
  public Promise<String> getSuccessPromise() {
    //create Future object
    Promise<String> promise = Promise.promise();
    //empty response injection
    promise.complete("Hello I am Promise result!!");
    return promise;
  }

  public Future<String> getSuccessPromise1() {
    //create Future object
    Promise<String> promise = Promise.promise();
    //empty response injection
    promise.complete("Hello I am Promise result!!");
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //convert promise into future
    getSuccessPromise().future().onSuccess(System.out::println);
    getSuccessPromise1().onSuccess(System.out::println);

  }
}


public class PromiseMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(PromiseMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PromiseVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Legacy Application flow : object oriented and sync flow
  
dependent operations  , should happen one by one

Object oriented seq work flow

 1.connect db - connect()
 2.Query results -queryResult()
 3.Formate results -formateResult()
 4.add results into http response stream - write()
 5.send/flush the results to clients - send()

 Connection con=connect();
 QueryResult queryres=con.queryResult()
 List<T> results = formatResult(queryres)
 response.write(results)
 reponse.end();
 .......................................................................................
How the above task can be done in functional programming ; vertx?


Functional sequential workflow:

 Nested Callback : Callback chaining: functional style

  Handler function is called as callback function

"The out put of one callback is input to the another callback : nested callbacks

   cb1
     --cb2
         -cb3
            --cbN
              --process the result.


Use case :

 getUser ----|if data is available
			|	|
			|
			      	 call login method with  output of getUser
                        |
		     if not
			 -error

Note : output of one function will be input to another function.


package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class CallbackVerticle extends AbstractVerticle {

  //getUser--->login--->other---untill you get final

  public Future<String> getUser() {
    Promise promise = Promise.promise();
    String userName = "admin";
    if (userName != null) {
      //output
      promise.complete(userName);
    } else {
      promise.fail(new RuntimeException("User not found"));
    }
    return promise.future();
  }

  public Future<String> login(String userName) {
    Promise promise = Promise.promise();
    if (userName.equals("admin")) {
      //output
      promise.complete("login success");
    } else {
      promise.fail(new RuntimeException("login failed"));
    }
    return promise.future();
  }

  public Future<String> showPage(String status) {
    Promise promise = Promise.promise();
    if (status.equals("login success")) {
      //output
      promise.complete("Welcome to Admin page");
    } else {
      promise.fail(new RuntimeException("You are inside Guest page"));
    }
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(userasync -> {
      if (userasync.succeeded()) {
        System.out.println("getUser is called");
        login(userasync.result()).onComplete(loginasync -> {
          if (loginasync.succeeded()) {
            System.out.println("login is called");
            showPage(loginasync.result()).onComplete(pageasync -> {
              System.out.println("get page is called");
              if (pageasync.succeeded()) {
                System.out.println(pageasync.result());
              } else {
                System.out.println(pageasync.cause());
              }
            });
          } else {
            System.out.println(loginasync.cause());
          }
        });
      } else {
        System.out.println(userasync.cause());
      }
    });
  }
}

public class CallbackChainingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackChainingVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new CallbackVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
callback Hell:
 The way we write nested callbacks.
 doom of pyrmid

    getUser().onComplete(userasync -> {
      if (userasync.succeeded()) {
        System.out.println("getUser is called");
        login(userasync.result()).onComplete(loginasync -> {
          if (loginasync.succeeded()) {
            System.out.println("login is called");
            showPage(loginasync.result()).onComplete(pageasync -> {
              System.out.println("get page is called");
              if (pageasync.succeeded()) {
                System.out.println(pageasync.result());
              } else {
                System.out.println(pageasync.cause());
              }
            });
          } else {
            System.out.println(loginasync.cause());
          }
        });
      } else {
        System.out.println(userasync.cause());
      }
    });

Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!

This is called callback hell; The callback hell is way of writing complex callbacks.



can we escape from callback hell problem, how to write better callback based programming?

Yes! 


Solution to callback Hell:
..........................
compose method of Future & Promise 


package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class CallbackHellVerticle extends AbstractVerticle {

  public Future<String> getUser() {
    Promise<String> promise = Promise.promise();
    //biz
    String userName = "admin";
    if (userName != null) {
      promise.complete(userName);
    } else {
      promise.fail("User not found");
    }

    return promise.future();
  }

  public Future<String> login(String userName) {
    Promise<String> promise = Promise.promise();
    //biz
    if (userName.equals("admin")) {
      promise.complete("login success");
    } else {
      promise.fail("login failed");
    }
    return promise.future();
  }

  public Future<String> page(String status) {
    Promise<String> promise = Promise.promise();
    //biz
    if (status.equals("login success")) {
      promise.complete("Admin Page");
    } else {
      promise.fail("Guest Page");
    }
    return promise.future();
  }

  public void callbackHellCode() {
    getUser().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("getUser is called ");
        login(event.result()).onComplete(loginevent -> {
          if (loginevent.succeeded()) {
            System.out.println("login is called");
            page(loginevent.result()).onComplete(pageevent -> {
              System.out.println("Page is called");
              if (pageevent.succeeded()) {
                System.out.println(pageevent.result());
              } else {
                System.out.println(pageevent.cause());
              }
            });
          } else {
            System.out.println(loginevent.cause());
          }
        });
      } else {
        System.out.println(event.cause());
      }
    });
  }

  //compose method of Future / Promise eleminate the complexity of callback nesting
  public void compose() {
    getUser()
      .compose(userName -> {
        return login(userName);
      })
      .compose(status -> {
        return page(status);
      })
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

    getUser()
      .compose(userName -> login(userName))
      .compose(status -> page(status))
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    getUser()
      .compose(this::login)
      .compose(this::page)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

  }


  @Override
  public void start() throws Exception {
    super.start();
    //callbackHellCode();
    compose();
  }
}


public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackHellSoultion.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new CallbackHellVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Data Formate in vertx:

1.Buffer
2.JSON object

Buffer
JSON


Buffer:

1.Verticles running in vertx often need to process blocks of data.
2.For instance , data from an incomming http request, data loaded from the disk or data generated as response to http request etc.
3.A Buffer in vertx can hold binary data.
4.Buffer is similar to byte array, except the buffer can expand its capacity dynamically  as you write data to it.


package com.ibm.vertx.core.dataformat;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;

public class BufferMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BufferMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    Buffer buffer = Buffer.buffer();
    buffer.appendString("Hello");
    buffer.appendString("Hai");
    buffer.appendString("Welcome");
    buffer.appendString("How are you");
    buffer.appendString("this is binary data");
    System.out.println(buffer.length());
    System.out.println(buffer.toString());
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////

JSON Object :Data Interchange format 

Vertx provides a Json Objects

1.JsonObject
2.JsonArray


Concept: fluent Pattern:

fluent pattern is nothing but builder pattern/chaining pattern.

Most of the vertx apis are based fluent.


package com.ibm.vertx.core.dataformat;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public void createSimpleJSON() {
    JsonObject profile = new JsonObject();
    //create json
    profile.put("id", 1);
    profile.put("name", "Subramanian");
    profile.put("status", true);
    //read data
    System.out.println(profile.getInteger("id"));
    System.out.println(profile.getString("name"));
    System.out.println(profile.getBoolean("status"));
    //print full
    System.out.println(profile.encodePrettily());


  }

  public void createfluentJSON() {
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true);
    //read data
    System.out.println(profile.getInteger("id"));
    System.out.println(profile.getString("name"));
    System.out.println(profile.getBoolean("status"));
    //print full
    System.out.println(profile.encodePrettily());

  }

  public void createNestedJSON() {
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true)
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadue"));
    //read data
    System.out.println(profile.getInteger("id"));
    System.out.println(profile.getString("name"));
    System.out.println(profile.getBoolean("status"));
    //print full
    System.out.println(profile.encodePrettily());
  }

  public void createJSONArray() {
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true)
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadu"));

    JsonArray profiles = new JsonArray()
      .add(profile)
      .add(new JsonObject()
        .put("id", 2)
        .put("name", "Ram")
        .put("status", true)
        .put("address", new JsonObject()
          .put("city", "Chennai")
          .put("state", "Tamil Nadu")));

    //print full
    System.out.println(profiles.encodePrettily());
  }

  public void mergeJson(JsonObject newConfig) {
    JsonObject config = new JsonObject()
      .put("http.port", 8080)
      .mergeIn(newConfig);
    System.out.println(config.encodePrettily());
  }

  //how to encapulate json / json array into promise/future
  public Future<JsonArray> getList() {
    Promise<JsonArray> profileList = Promise.promise();
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true)
      .put("address", new JsonObject()
        .put("city", "Coimbatore")
        .put("state", "Tamil Nadu"));

    JsonArray profiles = new JsonArray()
      .add(profile)
      .add(new JsonObject()
        .put("id", 2)
        .put("name", "Ram")
        .put("status", true)
        .put("address", new JsonObject()
          .put("city", "Chennai")
          .put("state", "Tamil Nadu")));

    profileList.complete(profiles);

    return profileList.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
//    createSimpleJSON();
//    createfluentJSON();
//    createNestedJSON();
//    createJSONArray();
    mergeJson(new JsonObject().put("http.host", "example.com").put("http.ssl", true));
    getList().onSuccess(profiles -> {
      System.out.println(profiles.encodePrettily());
    });
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Non blocking apis:

->Creating TCP clients and servers
->Creating HTTP clients and servers
->Creating DNS clients
->Creating Datagram sockets
->Setting and cancelling periodic and one-shot timers
->Getting a reference to the event bus API
->Getting a reference to the file system API


Timer api:
.........
package com.ibm.vertx.core.async.timers;

import io.vertx.core.*;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import java.util.Date;

public class TimersVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimersVerticle.class);
  }

  //delay
  public Future<JsonObject> delay(long duration) {
    Promise<JsonObject> promise = Promise.promise();
    //trigger nonblocking api, wait for result,
    vertx.setTimer(duration, asyncResult -> {
      //do something once timer has fired
      promise.complete(new JsonObject().put("message", "Hello i am delayed Message"));
    });
    return promise.future();
  }

  //heart beat
  public void heartBeat(Handler<AsyncResult<String>> aHandler) {
    long timerId = vertx.setPeriodic(1000, heartBeatValue -> {
      //send something every 1000ms
      aHandler.handle(Future.succeededFuture(new Date().toString()));
    });
    //stop the timer based on timerId;
    vertx.setTimer(8000, stopvalue -> {
      System.out.println("Stopping timer");
      vertx.cancelTimer(timerId);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    //blocking coding
    System.out.println("start");
    delay(5000).onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result().encodePrettily());
      }
    });
    heartBeat(now -> {
      System.out.println(now.result());
    });

    System.out.println("end");
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////

package com.ibm.vertx.core.fs;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.file.FileSystem;
import io.vertx.example.util.Runner;

public class FileSystemVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FileSystemVerticle.class);
  }

  public void readFile() {
    FileSystem fileSystem = vertx.fileSystem();
    fileSystem.readFile("assets/info.txt", fileHandler -> {
      if (fileHandler.succeeded()) {
        System.out.println(fileHandler.result().toString());
      } else {
        System.out.println(fileHandler.cause().getCause());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("start");
    readFile();
    System.out.println("end");
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////

HTTP Application:
................

How to build non blocking web application

vertx offers low level api called
 vertx.createHttpServer()

Objects:

1.HttpServer
2.HttpServerRequest
3.HttpServerResponse

All these objects are created already by vertx and only we use references.


package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class BasicHttpServer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BasicHttpServer.class);
  }

  public void createServer() {
    //create server object
    HttpServer httpServer = vertx.createHttpServer();

    //request handling
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      //send a response
      response.end("Hello Vertx Web Server");
    });

public void createFluentServer() {
    vertx.createHttpServer()
      .requestHandler(request -> request.response().end("Hello Vertx Web Server"))
      .listen(3001, serverHandler -> {
        if (serverHandler.succeeded()) {
          System.out.println("Server is ready at " + serverHandler.result().actualPort());
        } else {
          System.out.println(serverHandler.cause());
        }
      });
  }

    //start the server
    httpServer.listen(3000, serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Server is ready at " + serverHandler.result().actualPort());
      } else {
        System.out.println(serverHandler.cause());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    //createServer();
    createFluentServer();

  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class SendHtml extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SendHtml.class);
  }


  public void createFluentServer() {
    vertx.createHttpServer()
      .requestHandler(request -> request
        .response()
        .putHeader("content-type", "text/html")
        .end("<html><body><h1>Hello from vert.x!</h1></body></html>"))
      .listen(3001, serverHandler -> {
        if (serverHandler.succeeded()) {
          System.out.println("Server is ready at " + serverHandler.result().actualPort());
        } else {
          System.out.println(serverHandler.cause());
        }
      });
  }

  @Override
  public void start() throws Exception {
    super.start();
    //createServer();
    createFluentServer();
  }
}


Sending JSON Response:
......................

package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class SendJson extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SendJson.class);
  }
  public void sendJson() {
    //create server
    HttpServer httpServer = vertx.createHttpServer();
    //start handling request-response in non blocking
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      response.putHeader("content-type", "application/json");
      JsonObject message = new JsonObject()
        .put("name", "Subramanian")
        .put("message", "welcome");
      response.end(message.encodePrettily());
    });
    //start the server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });
  }
  @Override
  public void start() throws Exception {
    super.start();
    sendJson();
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////

RESTFull web services
Dynamic web application.


/api/products  - GET,POST,DELETE,PUT,...
/api/customers
/api/accounts

Routing using Http Module:

package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class RequestMappingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(RequestMappingVerticle.class);
  }

  public void simpleRouter() {
    //create server object
    HttpServer httpServer = vertx.createHttpServer();
    //request handling
    httpServer.requestHandler(request -> {
      System.out.println(request.uri() + " " + request.method());
      HttpServerResponse response = request.response();

      if (request.uri().equals("/") && request.method() == HttpMethod.GET) {
        //send a response
        response.putHeader("content-type", "text/html").end("<h1>Home</h1>");
      }

      if (request.uri().equals("/api/hello") && request.method() == HttpMethod.GET) {
        //send a response
        response.putHeader("content-type", "text/html").end("<h1>Hello Vertx Web Server</h1>");
      }
      if (request.uri().equals("/api/hai") && request.method() == HttpMethod.GET) {
        //send a response
        response.putHeader("content-type", "text/html").end("<h1>Hai Vertx Web Server</h1>");
      }

    });

    //start the server
    httpServer.listen(3000, serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Server is ready at " + serverHandler.result().actualPort());
      } else {
        System.out.println(serverHandler.cause());
      }
    });
  }


  @Override
  public void start() throws Exception {
    super.start();
    simpleRouter();
  }
}

The draw backs in the above code (core http module)

-URL and method mapping , need to be written manually.

How to solve it?

Vertx provides a mini web framework, called "vertx-web" , module for advanced web programming.


Vertx-Web Objects:
/////////////////

1.Router
2.Route
3.RouteContext === Servlet context



package com.ibm.vertx.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;

public class BasicRouters extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BasicRouters.class);
  }

  public void home(RoutingContext routingContext) {
    //using routing context , you can get request and response objects
    routingContext.response().putHeader("content-type", "text/html").end("<h1>Home</h1>");
  }

  public void createServer() {
    //create server object
    HttpServer httpServer = vertx.createHttpServer();

    //Routers : method and url mapping using vertx-web module
    //router is entry, which has collection of routes
    Router router = Router.router(vertx);
    //routes
    //router.HTTPmethod("url)
    router.get("/").handler(this::home);
    router.get("/api/hello").handler(routingContext -> {
      //using routing context , you can get request and response objects
      routingContext.response().putHeader("content-type", "text/html").end("<h1>Hello!!</h1>");
    });
    router.get("/api/hai").handler(routingContext -> {
      //using routing context , you can get request and response objects
      routingContext.response().putHeader("content-type", "text/html").end("<h1>Hai!!</h1>");
    });
    //request handling
    httpServer.requestHandler(router);
    //start the server
    httpServer.listen(3000, serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Server is ready at " + serverHandler.result().actualPort());
      } else {
        System.out.println(serverHandler.cause());
      }
    });
  }


  @Override
  public void start() throws Exception {
    super.start();
    createServer();
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Micro service applications:
..........................

Service :

 Representation of biz functionality
 Services are represented by objects
 
An application is collection of services.

-Services can talk each other 
  Why
    --to exchange message

How data/message can be shared?

HTTP style  --HTTP Protocal
Distributed Message Brokers - AMQP,...
IPC --TCP /


HTTP Communication:

-Provder --- web rest end point
-Consumer ---another service/web end point
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Web Client:

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-web-client</artifactId>
 <version>3.9.3</version>
</dependency>

The Web Client makes easy to do HTTP request/response interactions with a web server


package com.ibm.vertx.microservices.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;

public class ProviderServiceVerticle extends AbstractVerticle {

  public void home(RoutingContext routingContext) {
    //using routing context , you can get request and response objects
    routingContext.response().putHeader("content-type", "text/html").end("<h1>Home</h1>");
  }

  public void start() throws Exception {
    super.start();
    //create server object
    HttpServer httpServer = vertx.createHttpServer();

    //Routers : method and url mapping using vertx-web module
    //router is entry, which has collection of routes
    Router router = Router.router(vertx);
    //routes
    //router.HTTPmethod("url)
    router.get("/").handler(this::home);
    router.get("/api/hello").handler(routingContext -> {
      //using routing context , you can get request and response objects
      routingContext.response().putHeader("content-type", "text/html").end("<h1>Hello!!</h1>");
    });
    router.get("/api/hai").handler(routingContext -> {
      //using routing context , you can get request and response objects
      routingContext.response().putHeader("content-type", "text/html").end("<h1>Hai!!</h1>");
    });
    //request handling
    httpServer.requestHandler(router);
    //start the server
    httpServer.listen(3000, serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Provider Server is ready at " + serverHandler.result().actualPort());
      } else {
        System.out.println(serverHandler.cause());
      }
    });

  }
}


package com.ibm.vertx.microservices.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpServer;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;

public class ConsumerServiceVerticle extends AbstractVerticle {
  WebClient webClient;

  public void home(RoutingContext routingContext) {
    //create WebClient instance
    webClient = WebClient.create(vertx);
    Integer port = 3000;
    String host = "localhost";
    String url = "/";
    webClient.get(port, host, url).send(ar -> {
      if (ar.succeeded()) {
        //Obtain Response
        HttpResponse<Buffer> response = ar.result();
        System.out.println(response.bodyAsString());
        routingContext.response().end(response.bodyAsString());
      } else {
        System.out.println(ar.cause());
      }
    });

  }

  public void hello(RoutingContext routingContext) {
    //create WebClient instance
    webClient = WebClient.create(vertx);
    Integer port = 3000;
    String host = "localhost";
    String url = "/api/hello";
    webClient.get(port, host, url).send(ar -> {
      if (ar.succeeded()) {
        //Obtain Response
        HttpResponse<Buffer> response = ar.result();
        System.out.println(response.bodyAsString());
        routingContext.response().end(response.bodyAsString());
      } else {
        System.out.println(ar.cause());
      }
    });


  }

  @Override
  public void start() throws Exception {
    super.start();
    HttpServer httpServer = vertx.createHttpServer();
    //Routers : method and url mapping using vertx-web module
    //router is entry, which has collection of routes
    Router router = Router.router(vertx);
    //routes
    //router.HTTPmethod("url)
    router.get("/").handler(this::home);
    router.get("/api/greeter/hello").handler(this::hello);

    //request handling
    httpServer.requestHandler(router);

    httpServer.listen(3001, handler -> {
      if (handler.succeeded()) {
        System.out.println("Consumer Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Consumer Server is down!!!" + handler.cause());
      }
    });
  }
}
package com.ibm.vertx.microservices.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class HttpMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HttpMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ProviderServiceVerticle());
    vertx.deployVerticle(new ConsumerServiceVerticle());
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                             Service Types
                                                 |
                                  ------------------------------------
                                 Front End Service                Back End Service
                                     |                                  |
                                public Rest endpoint              Private Services.


Public Rest endpoint services are communicated via Http protocal.
  -Web --> WebClient

Private Services are commmunicated via tcp ,message brokers like protocal.


Event Bus:

-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.
-Event Bus uses tcp transport layer by default
-EventBus can send and recive data in the form of json and buffer


How verticle has been designed to adopt this architecture?

Verticle follows a design pattern  "Actor-like Model" ---->Actor Model design pattern


Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes   and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

   Per Vertx Engine only One Event Bus-singleTon



PUB-SUB:
........
package com.ibm.vertx.microservices.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;

class Address {
  public static String PUB_SUB_ADDRESS = "news.in.covid";
}

//pub-sub ; one provider many consumer
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}


//publisher publish news to all news tv channels
class PublisherVerticle extends AbstractVerticle {

  public void publish() {
    //Get EventBus Object reference
    EventBus eventBus = vertx.eventBus();
    String message = "Last 24 Hrs covid count is 80000";
    //send message with timer
    vertx.setTimer(1000, ar -> {
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    publish();
  }
}


public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  public void pubsub() {
    vertx.deployVerticle(new PublisherVerticle());
    vertx.deployVerticle(new NDTVVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
  }

  @Override
  public void start() throws Exception {
    super.start();
    pubsub();

  }
}
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.

POINT - TO POINT:
................
//point to point
class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 1 -  : " + news.body());
    });
  }

  public void consume2() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 2 -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
    consume2();
  }
}


//point to point publisher
class FinanceRequestVerticle extends AbstractVerticle {

  public void requestFinance() {
    System.out.println("Finance Request started....");
    vertx.setTimer(5000, ar -> {
      //point to point : send method
      String message = "Dear Team, We request that we want 1 Billion Money for Covid";
      //point to point ; send
      vertx.eventBus().send(Address.POINT_TO_POINT, message);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    requestFinance();
  }
}


Request -Reply:

class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUEST_REPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply("Patient is Crictal, Need More attention");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class ReportVerticle extends AbstractVerticle {

  public void sendReport() {
    vertx.setTimer(5000, ar -> {
      String message = "Report of Mr.x";
      vertx.eventBus().request(Address.REQUEST_REPLY, message, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
        } else {
          System.out.println(asyncResult.cause());
        }
      });
    });
  }

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Data Sources and vertx:
.......................

Vertx can talk to relationaldatabases and nosql databases as well in non blocking way.

Vertx uses non blocking jdbc dirvers to talk to relational databases

Verx has nosql driver implementation for mongodb,postgre...

/////////////////////////////////////////////////////////////////////////////////////////////////////

Vext-JDBC :

Database : in memory database hssql.

    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-jdbc-client</artifactId>
      <version>3.9.1</version>
    </dependency>
    <dependency>
      <groupId>org.hsqldb</groupId>
      <artifactId>hsqldb</artifactId>
      <version>2.3.4</version>
    </dependency>

Steps:
Connection
  // Create a JDBC client with a test database
    client = JDBCClient.createShared(vertx, new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver"));

Query Processing
getConnection(handler)
execute
query

create table,add mock data, query the initalie data
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.ibm.vertx.microservices.data;


import io.vertx.core.AbstractVerticle;
import io.vertx.core.Handler;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

public class JDBCVerticle extends AbstractVerticle {
  private static String CREATE_TABLE = "CREATE TABLE IF NOT EXISTS products(id INT IDENTITY, name VARCHAR(255), price FLOAT, weight INT)";
  private static String INITAL_TABLE_DATA = "INSERT INTO products (name, price, weight) VALUES ('Egg Whisk', 3.99, 150), ('Tea Cosy', 5.99, 100), ('Spatula', 1.00, 80)";
  private static String GET_ALL_PRODUCTS = "SELECT id, name, price, weight FROM products";
  private JDBCClient client;

  public static void main(String[] args) {
    Runner.runExample(JDBCVerticle.class);
  }

  public void startApplication() {
    JsonObject jdbcConfig = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver");
    //connect database
    client = JDBCClient.createShared(vertx, jdbcConfig);
    setUpInitialData(ready -> {

      Router router = Router.router(vertx);

      //Middleware injection /filter /interceptor ; // to json string from client and convert
      //into json object : body parsers
      router.route().handler(BodyHandler.create());

      // in order to minimize the nesting of call backs we can put the JDBC connection on the context for all routes
      // that match /products
      // this should really be encapsulated in a reusable JDBC handler that uses can just add to their app
      router.route("/products*").handler(routingContext ->
        client.getConnection(res -> {
          if (res.failed()) {
            routingContext.fail(res.cause());
          } else {
            SQLConnection conn = res.result();
            // save the connection on the context
            routingContext.put("conn", conn);
            // we need to return the connection back to the jdbc pool. In order to do that we need to close it, to keep
            // the remaining code readable one can add a headers end handler to close the connection.
            routingContext.addHeadersEndHandler(done -> conn.close(v -> {
              System.out.println(v.succeeded() ? "Connection Closed" : "Connection not closed");
            }));
            routingContext.next();
          }
        })).failureHandler(routingContext -> {
        SQLConnection conn = routingContext.get("conn");
        if (conn != null) {
          conn.close(v -> {
            System.out.println(v.succeeded() ? "Connection Closed" : "Connection not closed");
          });
        }
      });

      //router.get("/products/:productID").handler(that::handleGetProduct);
      // router.post("/products").handler(that::handleAddProduct);
      router.get("/products").handler(this::handleListProducts);

      vertx.createHttpServer().requestHandler(router).listen(8080);

    });
  }

  private void handleListProducts(RoutingContext routingContext) {
    HttpServerResponse response = routingContext.response();
    SQLConnection conn = routingContext.get("conn");
    conn.query(GET_ALL_PRODUCTS, query -> {
      if (query.failed()) {
        sendError(500, response);
      } else {
        JsonArray arr = new JsonArray();
        query.result().getRows().forEach(arr::add);
        routingContext.response().putHeader("content-type", "application/json").end(arr.encodePrettily());
      }
    });
  }

  private void sendError(int statusCode, HttpServerResponse response) {
    response.setStatusCode(statusCode).end();
  }

  private void setUpInitialData(Handler<Void> done) {
    client.getConnection(res -> {
      if (res.failed()) {
        throw new RuntimeException(res.cause());
      }
      final SQLConnection conn = res.result();

      //execute to create table
      conn.execute(CREATE_TABLE, ddl -> {
        if (ddl.failed()) {
          throw new RuntimeException(ddl.cause());
        }

        //insert inital rows
        conn.execute(INITAL_TABLE_DATA, fixtures -> {
          if (fixtures.failed()) {
            throw new RuntimeException(fixtures.cause());
          }
          done.handle(null);
        });
      });
    });

  }


  @Override
  public void start() throws Exception {
    super.start();
    startApplication();
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Golden Rule : Dont block event loop:
.....................................

There is no gurantee that vertx can offer 100% non blocking, what if i want to write blocking opertions inside vertx.

-Non blocking operations are handled by "Event Loop" Thread.
-Blocking operations should be off loaded outside event loop thread, grab result carefully without  blocking event loop.

does vertx supports blocking code? is blocking is neccessary?How do we write blocking code? 

Yes! vertx supports blocking code.

Yes!, you cant write 100% non blocking code
.
Use case : 

You are building vertx application, vertx application need to talk to hibernate/jpa layer.
Vertx is non blocking but hibernate blocking.

if you write blocking inside non blocking vertx will throw error, but how to bridge blocking with non-blocking.

Blocking code

-Thread.sleep
-long running task
-legacy file io
-legacy network 
-database 
-external api 
.....

Event loop thread can wait for 2000ms - default wait duration : event loop thread in vertx cant 
wait / be blocked for 2000ms.



package com.ibm.vertx.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;


class MyVerticle extends AbstractVerticle {
  public void blockMe() {
    try {
      Thread.sleep(10000);
    } catch (InterruptedException exception) {
      System.out.println(exception);
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //write blocking code
    blockMe();
    System.out.println(Thread.currentThread().getName());
  }
}


public class BlockingVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new MyVerticle());
  }
}


if you run the above code , vertx will throw the following messageSep 10, 2020 5:02:07 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-1,5,main]=Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 2031 ms, time limit is 2000 ms
Sep 10, 2020 5:02:08 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-1,5,main]=Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 3031 ms, time limit is 2000 ms
Sep 10, 2020 5:02:09 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-1,5,main]=Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 4031 ms, time limit is 2000 ms
Sep 10, 2020 5:02:10 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-1,5,main]=Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 5031 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.lang.Thread.sleep(Native Method)
	at com.ibm.vertx.blocking.MyVerticle.blockMe(BlockingVerticleMain.java:10)
	at com.ibm.vertx.blocking.MyVerticle.start(BlockingVerticleMain.java:20)
	at io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:108)
	at io.vertx.core.Verticle.start(Verticle.java:66)
	at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$9(DeploymentManager.java:556)
	at io.vertx.core.impl.DeploymentManager$$Lambda$11/764577347.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:366)
	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
	at io.vertx.core.impl.EventLoopContext$$Lambda$12/1690287238.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

How to create Worker Verticle?

Every Object in Vertx has its own configuration Object?

Eg:
HTTPServer instance has configuration object called HttpServerConfig
EventBus instance has configuration object called EventBusConfiguration
Vertx instance has configuration object Called VertxOptions
Verticle instance has configuration object Called - DeploymentOptions
...


How to convert standard verticle into worker verticle?

public DeploymentOptions setWorker(boolean worker)
Set whether the verticle(s) should be deployed as a worker verticle.

Deploying Verticle with deployment options.


package com.ibm.vertx.core.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class ServerVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    //Ensure server verticle deployement when httpserver succfully starts
    vertx.createHttpServer()
      .requestHandler(request -> request.response()
        .end("test"))
      .listen(3000, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          //ensure start method is finished
          startPromise.complete();
        } else {
          startPromise.fail("Failed ");
        }
      });
  }
}

class MyVerticle extends AbstractVerticle {
  public void blockMe() {
    try {
      Thread.sleep(10000);
    } catch (InterruptedException exception) {
      System.out.println(exception);
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    blockMe();
    System.out.println(Thread.currentThread().getName());
  }
}

public class BlockingMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(Thread.currentThread().getName());
    // for (int i = 0; i < 25; i++)
    DeploymentOptions options = new DeploymentOptions()
      .setWorker(true)
      .setWorkerPoolSize(10);
    vertx.deployVerticle(new MyVerticle(), options);
    // vertx.deployVerticle(new MyVerticle(), new DeploymentOptions().setWorker(true));
    vertx.deployVerticle(new MyVerticle(), options, completionHandler -> {
      if (completionHandler.succeeded()) {
        System.out.println("Verticle Deployed : " + completionHandler.result());
      } else {
        System.out.println("Verticle not deployed " + completionHandler.cause());
      }
    });

    //
    vertx.deployVerticle(new ServerVerticle(), completionHandler -> {
      if (completionHandler.succeeded()) {
        System.out.println("Verticle Deployed : " + completionHandler.result());
      } else {
        System.out.println("Verticle not deployed " + completionHandler.cause());
      }
    });
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Use case :

 I have verticle having 5 apis, only 1 api is blocking api, then i cant make entire verticle is worker
verticle.
 
 and also i want the result of blocking operation, return via non blocking operation

 eg :
 vertx http is non blocking, and hibernate call is blocking, i want to return blocking result via non blocking.


vertx provides various  safe blocking apis.
...........................................

vertx.executeBlocking
router.blockingHandler
eventbus.blockingHandler


i want to get blocking result , inside non blocking code : coordination between event loop and work pool threads
 - The out put of worker pool thread, need inside event loop thread.

<T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler,                       Handler<AsyncResult<T>> resultHandler)

-Safely execute some blocking code.
-Executes the blocking code in the handler blockingCodeHandler using a thread from the worker pool.
-When the code is complete the handler resultHandler will be called with the result on the original  context  (e.g. on the original event loop of the caller).


package com.ibm.vertx.core.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

public class ExcuteBlockingApiVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ExcuteBlockingApiVerticle.class);
  }
  private void sayHello(Promise<String> promise) {
    System.out.println("Say Hello : " + Thread.currentThread().getName());
    try {
      Thread.sleep(4000);
      System.out.println("Wake Up read to send data to Non blocking Service");
      //this result will be accessed inside non blocking code
      promise.complete("Hey this is blocking Result");

    } catch (InterruptedException es) {
      promise.fail("Something went wrong in blocking service");
    }
  }
  //read result from blocking service
  private void resultHandler(AsyncResult<String> ar) {
    System.out.println("Result Handler" + Thread.currentThread().getName());
    if (ar.succeeded()) {
      System.out.println("Blocking api Result goes Ready Here");
      System.out.println(ar.result());
    } else {
      System.out.println(ar.cause().getMessage());
    }
  }
  public void exchange() {
    //run blocking ,blocking code result i need inside nonblocking
    vertx.executeBlocking(this::sayHello, this::resultHandler);
  }
  @Override
  public void start() throws Exception {
    super.start();
    exchange();
  }
}

  public void httpblocking() {
    vertx.createHttpServer().requestHandler(request -> {
      vertx.<String>executeBlocking(promise -> {
        // Do the blocking operation in here
        // Imagine this was a call to a blocking API to get the result
        try {
          Thread.sleep(5000);
        } catch (Exception ignore) {
        }
        String result = "hello , i am blocked";

        promise.complete(result);

      }, res -> {
        if (res.succeeded()) {
          request.response().putHeader("content-type", "text/plain").end(res.result());
        } else {
          res.cause().printStackTrace();
        }
      });

    }).listen(8080);
  }

public void httpRouterBlocking() {
    HttpServer server = vertx.createHttpServer();
    Router router = Router.router(vertx);
    router.get("/blocking").blockingHandler(routingContext -> {
      try {
        //blocking code
        Thread.sleep(5000);
      } catch (Exception e) {

      }

      routingContext.response().end("Blocking result");
    });

    server.requestHandler(router);


    server.listen(8081, handler -> {
      if (handler.succeeded()) {
        System.out.println(handler.result().actualPort());
      }
    });
  }

//////////////////////////////////////////////////////////////////////////////////////////////////////

Vertx Configuration :Distributed Configuration:
.........................

How to configure Vertx application:

Vert.x Config
  This component provides an extensible way to configure Vert.x applications.


Configuration Stores(Storage):
..............................

Physical storage:

1.files
2.directories -ldap....
3.HTTP Servers - a separate HTTP server.
4.Redis
5.System Properties
6.environment properties
7.In memory Store: Application memory

Configuration representation inisde vertx is json object.

Storage file formats:
1.yaml
2.json
3.properties
......

Verticle:
 -can read config  data from the Vertx Context Object / DeploymentOptions
 -can read config data  from the file via command line args
 -can read from any storage via Vertx-Config module objects like ConfigReteriver.


Use Case 1 :Application inmememory configuration.

How to supply configuration info to Verticle?


 -can read config  data from the Vertx Context Object
     via DeploymentOptions we need to inject config data.

-via DeploymentOptions while verticle is being deployed.

-How to read configuration which was supplied via DeploymentOptions

AbstractVerticle has an api 

public JsonObject config()
Get the configuration of the verticle.
This can be specified when the verticle is deployed.

Returns:
the configuration


Steps:

1.create DeploymentOptions Object

JsonObject config=new JsonObject().put("message","Hello");

DeploymentOptions  options=new DeploymentOptions();

options.setConfig(config);



package com.ibm.vertx.microservices.config;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

//
class ApplicationConfigVerticle extends AbstractVerticle {

  @Override
  public void start() throws Exception {
    super.start();
    //read config
    JsonObject config = config();
    System.out.println(config.encodePrettily());
    System.out.println(config().getString("name"));
    System.out.println(config().getString("message", "default Message"));

    vertx.createHttpServer()
      .requestHandler(request -> {
        request.response().end(config().getString("message", "You are lucky!!"));
      })
      .listen(config().getInteger("http.port", 3000));

  }
}


public class VerticleConfiguration extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(VerticleConfiguration.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    JsonObject serverConfig = new JsonObject()
      .put("http.port", 3000)
      .put("http.host", "locahost")
      .put("http.ssl", false);

    JsonObject applicationConfig = new JsonObject()
      .put("name", "Subramanian")
      .put("city", "Coimbatore")
      .put("state", "TN")
      .mergeIn(serverConfig);
    DeploymentOptions options = new DeploymentOptions();
    options.setConfig(applicationConfig);
    vertx.deployVerticle(new ApplicationConfigVerticle(), options, dep -> {
      if (dep.succeeded()) {
        System.out.println(dep.result());
      }
    });

  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////
Vert can read from Operating system env variables and system properties
System.out.println(System.getProperty("java.home"));
System.out.println(System.getProperty("path.separator"));
System.out.println(System.getenv("path"));


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

How to read configuration from external configuration system.
 
Configuration system could be file,dir,git......


1.ConfigRetriever:

  It configures a set of configuration store, where Configuration store defines  a location 
  from where the configuration data is read and also format(JSON by default).

 The Result from ConfigRetriever is JSON object.

Flow

  Application ------------------|ConfigRetriver----|ConfigStore
				JSON Object	<----	


How to instantiate the ConfigRetriver:

 ConfigRetriver retriver = ConfigRetriver.create(vertx).


Reading from json file:

Note: ConfigRetiver uses by default json file. if you read other than json  you need to extra depedencies.

Steps:

1.Add Dependency.

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-config</artifactId>
 <version>3.9.2</version>
</dependency>

2.create resources/config/config.json file

{
  "appname": "IBM Vertx Application",
  "version": "1.0.0"
}

3.set storage options
   ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));

4.Create ConfigReteriver

    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(options));

    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        System.out.println(configRes.getString("appname"));
        System.out.println(configRes.getString("version"));

      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });


class ExternalConfigVerticle extends AbstractVerticle{
  @Override
  public void start() throws Exception {
    super.start();
    //store options
    ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));

    //config reteriver
    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(options));
    //read configuration
    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        System.out.println(configRes.getString("appname"));
        System.out.println(configRes.getString("version"));

      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });

  }
}


How to read YAML files

Steps:

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-config-yaml</artifactId>
 <version>3.9.2</version>
</dependency>

ConfigStoreOptions store = new ConfigStoreOptions()
  .setType("file")
  .setFormat("yaml")
  .setConfig(new JsonObject()
    .put("path", "my-config.yaml")
  );

ConfigRetriever retriever = ConfigRetriever.create(vertx,
    new ConfigRetrieverOptions().addStore(store));

/////////////////////////////////////////////////////////////////////////////////////////////////////

package com.ibm.vertx.microservices.config;

import io.vertx.config.ConfigRetriever;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class ExternalizeConfigVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(config().encodePrettily());
  }
}


class FileSystemConfigVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));
    ConfigRetriever retriever = ConfigRetriever.create(vertx,
      new ConfigRetrieverOptions().addStore(options));

    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        System.out.println(configRes.getString("appname"));
        System.out.println(configRes.getString("version"));

      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });


  }
}

//
class ApplicationConfigVerticle extends AbstractVerticle {


  @Override
  public void start() throws Exception {
    super.start();
    //read config
    JsonObject config = config();
    System.out.println(config.encodePrettily());
    System.out.println(config().getString("name"));
    System.out.println(config().getString("message", "default Message"));

    vertx.createHttpServer()
      .requestHandler(request -> {
        request.response().end(config().getString("message", "You are lucky!!"));
      })
      .listen(config().getInteger("http.port", 3000));

    //env and system
    System.out.println(System.getProperty("java.home"));
    System.out.println(System.getProperty("path.separator"));
    System.out.println(System.getenv("path"));

  }
}


public class VerticleConfiguration extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(VerticleConfiguration.class);
  }

  public Future<JsonObject> getConfig() {
    Promise<JsonObject> promise = Promise.promise();
    //store options
    ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));
    //config reteriver
    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(options));
    //read configuration
    retriever.getConfig(config -> {
      if (config.succeeded()) {
        promise.complete(config.result());
      } else {
        promise.fail("Config Error : " + config.cause());
      }
    });
    return promise.future();

  }

  @Override
  public void start() throws Exception {
    super.start();
//    JsonObject serverConfig = new JsonObject()
//      .put("http.port", 3000)
//      .put("http.host", "locahost")
//      .put("http.ssl", false);
//
//    JsonObject applicationConfig = new JsonObject()
//      .put("name", "Subramanian")
//      .put("city", "Coimbatore")
//      .put("state", "TN")
//      .mergeIn(serverConfig);
//    DeploymentOptions options = new DeploymentOptions();
//    options.setConfig(applicationConfig);
//    vertx.deployVerticle(new ApplicationConfigVerticle(), options, dep -> {
//      if (dep.succeeded()) {
//        System.out.println(dep.result());
//      }
//    });
//
//    vertx.deployVerticle(new FileSystemConfigVerticle());

    //////////////////////////////////////////////////////////////////////
    getConfig().onSuccess(myconfig -> {
      //  System.out.println(myconfig.encodePrettily());
      JsonObject config = new JsonObject()
        .put("name", "Subramnaian")
        .put("message", "Hello!!")
        .put("port", 8082)
        .mergeIn(myconfig);
      DeploymentOptions myoptions = new DeploymentOptions().setConfig(config);
      vertx.deployVerticle(new ExternalizeConfigVerticle(), myoptions);
    });

  }
}
/////////////////////////////****************************//////////////////////////////////////////////

Vertx Types:
...........

1.Standard Vertx
2.Clustered Vertx

Distributed Architecture: Microservices
.......................................


Verticle Communication:
......................

1.Within Process : 

  Within single Vertx

2.among Vertx


Vertx - Clustering:
...................

Clustering , means organization application under one communication channel.

Vertx uses integration/clustering technologies.

Vertx uses hazelcast ClusterManager/provider by default.

Cluster : group of something - group of verticles/vertx instance/jvm

in order to connect vertx apps across processes, we need cordinator 
-Bride softwares

Vertx can work with
-hazelcast
-apache zookeeper
-apache ignite
-apache Infinispan

ClusterManagers

by default, vertx has hazelcast, we dont need to configure by default.


How to enable clustering?

In vertx clustering can be enabled in two ways

1.through code

Vertx Configuration;

Types of vertx:
1.standard vertx
2.clusteredVertx

Vertx.createClusteredVertx()


2.through vertx command line

  vertx program.java -cluster


3.through Lanucher class as well


Steps for clustering:
....................

<dependency>
      <groupId>com.hazelcast</groupId>
      <artifactId>hazelcast</artifactId>
      <version>3.12.2</version>
</dependency>

Cluster Configuration:

two ways

1.through code

2.through configuration files
 -hazelcast uses file  cluster.xml

Create ClusteManager

Config hazelcastConfig = new Config();

// Now set some stuff on the config (omitted)

ClusterManager mgr = new HazelcastClusterManager(hazelcastConfig);



ClusterManager mgr = new HazelcastClusterManager(hazelcastConfig);

    ClusterManager mgr = new HazelcastClusterManager();
    
    VertxOptions options = new VertxOptions().setClusterManager(mgr);

    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {

       //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions();       
        
        vertxAsyncResult.result().deployVerticle("com.ibm.vertx.core.distributed.cluster.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&




















